<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Vue响应式原理 | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1 什么是Vue响应式呢 ❝ 数据发生变化后，会重新对页面渲染，这就是Vue响应式 ❞  响应式图例 2 想完成这个过程，我们需要做些什么 侦测数据的变化 收集视图依赖了哪些数据 数据变化时，自动“通知”需要更新的视图部分，并进行更新  「它们对应专业俗语分别是：」  数据劫持 &#x2F; 数据代理 依赖收集 发布订阅模式  3 如何侦测数据的变化有两种办法可以侦测到变化： 使用Object.define">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue响应式原理">
<meta property="og:url" content="http://example.com/2020/12/08/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1 什么是Vue响应式呢 ❝ 数据发生变化后，会重新对页面渲染，这就是Vue响应式 ❞  响应式图例 2 想完成这个过程，我们需要做些什么 侦测数据的变化 收集视图依赖了哪些数据 数据变化时，自动“通知”需要更新的视图部分，并进行更新  「它们对应专业俗语分别是：」  数据劫持 &#x2F; 数据代理 依赖收集 发布订阅模式  3 如何侦测数据的变化有两种办法可以侦测到变化： 使用Object.define">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.obzhi.com/wp-content/uploads/2021/01/mojie2-1024x470.jpeg">
<meta property="article:published_time" content="2020-12-08T07:45:47.000Z">
<meta property="article:modified_time" content="2021-03-16T07:49:51.769Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.obzhi.com/wp-content/uploads/2021/01/mojie2-1024x470.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2020/12/08/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-03-16 15:49:51'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 有链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://www.obzhi.com/wp-content/uploads/2021/01/mojie2-1024x470.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hexo</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 有链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Vue响应式原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-12-08T07:45:47.000Z" title="发表于 2020-12-08 15:45:47">2020-12-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-03-16T07:49:51.769Z" title="更新于 2021-03-16 15:49:51">2021-03-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-什么是Vue响应式呢"><a href="#1-什么是Vue响应式呢" class="headerlink" title="1 什么是Vue响应式呢"></a>1 什么是Vue响应式呢</h2><blockquote>
<p>❝</p>
<p>数据发生变化后，会重新对页面渲染，这就是Vue响应式</p>
<p>❞</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/12/17343bec8052a2ff?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="响应式图例">响应式图例</p>
<h2 id="2-想完成这个过程，我们需要做些什么"><a href="#2-想完成这个过程，我们需要做些什么" class="headerlink" title="2 想完成这个过程，我们需要做些什么"></a>2 想完成这个过程，我们需要做些什么</h2><ul>
<li>侦测数据的变化</li>
<li>收集视图依赖了哪些数据</li>
<li>数据变化时，自动“通知”需要更新的视图部分，并进行更新</li>
</ul>
<p><strong>「它们对应专业俗语分别是：」</strong></p>
<ul>
<li>数据劫持 / 数据代理</li>
<li>依赖收集</li>
<li>发布订阅模式</li>
</ul>
<h2 id="3-如何侦测数据的变化"><a href="#3-如何侦测数据的变化" class="headerlink" title="3 如何侦测数据的变化"></a>3 如何侦测数据的变化</h2><p>有两种办法可以侦测到变化：<br> 使用<code>Object.defineProperty</code>和ES6的<code>Proxy</code>，这就是进行数据劫持或数据代理。</p>
<h3 id="3-1-Object-defineProperty实现"><a href="#3-1-Object-defineProperty实现" class="headerlink" title="3.1  Object.defineProperty实现"></a>3.1  Object.defineProperty实现</h3><p>Vue通过设定对象属性的 <code>setter/getter</code> 方法来监听数据的变化，通过<code>getter</code>进行依赖收集，而每个<code>setter</code>方法就是一个<code>观察者</code>，在<code>数据变更</code>的时候通知<code>订阅者</code>更新视图。</p>
<h4 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function render () &#123;</span><br><span class="line">&#x2F;&#x2F;set的时候会走这里，重新渲染</span><br><span class="line">  console.log(&#39;模拟视图渲染&#39;)</span><br><span class="line">&#125;</span><br><span class="line">let data &#x3D; &#123;</span><br><span class="line">  name: &#39;浪里行舟&#39;,</span><br><span class="line">  location: &#123; x: 100, y: 100 &#125;</span><br><span class="line">&#125;</span><br><span class="line">observe(data)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>定义核心函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function observe (obj) &#123; &#x2F;&#x2F; 我们来用它使对象变成可观察的</span><br><span class="line">  &#x2F;&#x2F; 判断类型</span><br><span class="line">  if (!obj || typeof obj !&#x3D;&#x3D; &#39;object&#39;) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  Object.keys(obj).forEach(key &#x3D;&gt; &#123;</span><br><span class="line">    defineReactive(obj, key, obj[key])</span><br><span class="line">  &#125;)</span><br><span class="line">  function defineReactive (obj, key, value) &#123;</span><br><span class="line">    &#x2F;&#x2F; 递归子属性</span><br><span class="line">    observe(value)</span><br><span class="line">    Object.defineProperty(obj, key, &#123;</span><br><span class="line">      enumerable: true, &#x2F;&#x2F;可枚举（可以遍历）</span><br><span class="line">      configurable: true, &#x2F;&#x2F;可配置（比如可以删除）</span><br><span class="line">      get: function reactiveGetter () &#123;</span><br><span class="line">        console.log(&#39;get&#39;, value) &#x2F;&#x2F; 监听</span><br><span class="line">        return value</span><br><span class="line">      &#125;,</span><br><span class="line">      set: function reactiveSetter (newVal) &#123;</span><br><span class="line">        observe(newVal) &#x2F;&#x2F;如果赋值是一个对象，也要递归子属性</span><br><span class="line">        if (newVal !&#x3D;&#x3D; value) &#123;</span><br><span class="line">          console.log(&#39;set&#39;, newVal) &#x2F;&#x2F; 监听</span><br><span class="line">          render()</span><br><span class="line">          value &#x3D; newVal</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>改变data的属性，会出发set；然后获取data的属性，会触发get</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data.location &#x3D; &#123;</span><br><span class="line">  x: 1000,</span><br><span class="line">  y: 1000</span><br><span class="line">&#125; &#x2F;&#x2F;打印     set &#123;x: 1000,y: 1000&#125; 模拟视图渲染</span><br><span class="line">data.name &#x2F;&#x2F;打印   get 浪里行舟</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong>「上面这段代码的主要作用在于：」</strong><br> observe这个函数传入一个 <code>obj（需要被追踪变化的对象）</code>，通过遍历所有属性的方式对该对象的每一个属性都通过 <code>defineReactive</code> 处理,给每个属性加上<code>set</code>和<code>get</code>方法,以此来达到实现侦测对象变化。值得注意的是，observe 会进行递归调用。</p>
<p><strong>「那我们如何侦测Vue中data 中的数据，其实也很简单：」</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Vue &#123;</span><br><span class="line">    &#x2F;* Vue构造类 *&#x2F;</span><br><span class="line">    constructor(options) &#123;</span><br><span class="line">        this._data &#x3D; options.data;</span><br><span class="line">        observer(this._data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这样我们只要 new 一个 Vue 对象，就会将 data 中的数据进行追踪变化。</p>
<p><strong>「但是我们发现一个问题，上面的代码无法检测到对象属性的<code>添加或删除</code>(如data.location.a=1,增加一个a属性)。」</strong><br> 这是因为 Vue 通过Object.defineProperty来将对象的key转换成getter/setter的形式来追踪变化，但getter/setter只能追踪一个数据<code>是否被修改</code>，无法追踪<code>新增属性和删除</code>属性。如果是删除属性，我们可以用<code>vm.$delete</code>实现，那如果是新增属性，该怎么办呢？</p>
<ol>
<li>可以使用 Vue.set(location, a, 1) 方法向嵌套对象添加响应式属性;</li>
<li>也可以给这个对象重新赋值，比如data.location = {…data.location,a:1}</li>
</ol>
<p>Object.defineProperty 不能监听数组的变化，需要进行数组方法的重写</p>
<h3 id="3-2-Proxy实现"><a href="#3-2-Proxy实现" class="headerlink" title="3.2  Proxy实现"></a>3.2  Proxy实现</h3><p>Proxy 是 <code>JavaScript 2015</code> 的一个新特性。Proxy 的<code>代理</code>是针对<code>整个对象</code>的，而不是对象的某个属性，因此不同于 Object.defineProperty 的必须遍历对象每个属性，Proxy 只需要做<code>一层代</code>理就可以监听<code>同级结构</code>下的所有属性变化，当然对于<code>深层结构</code>，递归还是需要进行的。此外Proxy支持代理<code>数组</code>的变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function render() &#123;</span><br><span class="line">  console.log(&#39;模拟视图的更新&#39;)</span><br><span class="line">&#125;</span><br><span class="line">let obj &#x3D; &#123;</span><br><span class="line">  name: &#39;前端工匠&#39;,</span><br><span class="line">  age: &#123; age: 100 &#125;,</span><br><span class="line">  arr: [1, 2, 3]</span><br><span class="line">&#125;</span><br><span class="line">let handler &#x3D; &#123;</span><br><span class="line">  get(target, key) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果取的值是对象就再对这个对象进行数据劫持</span><br><span class="line">    if (typeof target[key] &#x3D;&#x3D; &#39;object&#39; &amp;&amp; target[key] !&#x3D;&#x3D; null) &#123;</span><br><span class="line">      return new Proxy(target[key], handler)</span><br><span class="line">    &#125;</span><br><span class="line">    return Reflect.get(target, key)</span><br><span class="line">  &#125;,</span><br><span class="line">  set(target, key, value) &#123;</span><br><span class="line">  &#x2F;&#x2F;key为length时，表示遍历完了最后一个属性</span><br><span class="line">    if (key &#x3D;&#x3D;&#x3D; &#39;length&#39;) return true</span><br><span class="line">    render()</span><br><span class="line">    return Reflect.set(target, key, value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let proxy &#x3D; new Proxy(obj, handler)</span><br><span class="line">proxy.age.name &#x3D; &#39;浪里行舟&#39; &#x2F;&#x2F; 支持新增属性</span><br><span class="line">console.log(proxy.age.name) &#x2F;&#x2F; 模拟视图的更新 浪里行舟</span><br><span class="line">proxy.arr[0] &#x3D; &#39;浪里行舟&#39; &#x2F;&#x2F;支持数组的内容发生变化</span><br><span class="line">console.log(proxy.arr) &#x2F;&#x2F; 模拟视图的更新 [&#39;浪里行舟&#39;, 2, 3 ]</span><br><span class="line">proxy.arr.length-- &#x2F;&#x2F; 无效</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>以上代码不仅精简，而且还是实现一套代码对对象和数组的侦测都适用。不过Proxy兼容性不太好！</p>
<h2 id="4-收集依赖"><a href="#4-收集依赖" class="headerlink" title="4. 收集依赖"></a>4. 收集依赖</h2><h3 id="4-1-为什么要收集依赖"><a href="#4-1-为什么要收集依赖" class="headerlink" title="4.1 为什么要收集依赖"></a>4.1 为什么要收集依赖</h3><blockquote>
<p>❝</p>
<p>我们之所以要观察数据，其目的在于当数据的属性发生变化时，可以通知那些曾经使用了该数据的地方。比如例子中，模板中使用了location 数据，当它发生变化时，要向使用了它的地方发送通知。</p>
<p>❞</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let globalData &#x3D; &#123;</span><br><span class="line">    text: &#39;浪里行舟&#39;</span><br><span class="line">&#125;;</span><br><span class="line">let test1 &#x3D; new Vue(&#123;</span><br><span class="line">    template:</span><br><span class="line">        &#96;&lt;div&gt;</span><br><span class="line">            &lt;span&gt;&#123;&#123;text&#125;&#125;&lt;&#x2F;span&gt; </span><br><span class="line">        &lt;div&gt;&#96;,</span><br><span class="line">    data: globalData</span><br><span class="line">&#125;);</span><br><span class="line">let test2 &#x3D; new Vue(&#123;</span><br><span class="line">    template:</span><br><span class="line">        &#96;&lt;div&gt;</span><br><span class="line">            &lt;span&gt;&#123;&#123;text&#125;&#125;&lt;&#x2F;span&gt; </span><br><span class="line">        &lt;div&gt;&#96;,</span><br><span class="line">    data: globalData</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如果我们执行下面这条语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">globalData.text &#x3D; &#39;前端工匠&#39;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>此时我们需要通知 <code>test1</code> 以及 <code>test2</code> 这两个Vue实例进行视图的<code>更新</code>,我们只有通过<code>收集依赖</code>才能知道哪些地方依赖我的数据，以及数据更新时<code>派发更新</code>。那依赖收集是如何实现的？其中的核心思想就是“事件发布订阅模式”。接下来我们先介绍两个重要角色– <code>订阅者 Dep</code>和<code>观察者 Watcher</code> ，然后阐述收集依赖的如何实现的。</p>
<h3 id="4-2-订阅者-Dep"><a href="#4-2-订阅者-Dep" class="headerlink" title="4.2 订阅者 Dep"></a>4.2 订阅者 Dep</h3><p><strong>「为什么引入 Dep:」</strong><br> 收集依赖需要为依赖找一个存储依赖的地方，为此我们创建了Dep,它用来<code>收集依赖</code>、<code>删除依赖</code>和<code>向依赖发送</code>消息等。<br> 于是我们先来实现一个<code>订阅者 Dep 类</code>，用于<code>解耦属性</code>的依赖收集和派发更新操作，<strong>「说得具体点」</strong>:它的主要作用是用来<code>存放 Watcher 观察者</code>对象。我们可以把Watcher理解成一个<code>中介</code>的角色，<code>数据发生变化</code>时通知它，然后它再通知<code>其他地方</code>。</p>
<p><strong>「Dep的简单实现:」</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Dep &#123;</span><br><span class="line">    constructor () &#123;</span><br><span class="line">        &#x2F;* 用来存放Watcher对象的数组 *&#x2F;</span><br><span class="line">        this.subs &#x3D; [];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;* 在subs中添加一个Watcher对象 *&#x2F;</span><br><span class="line">    addSub (sub) &#123;</span><br><span class="line">        this.subs.push(sub);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;* 通知所有Watcher对象更新视图 *&#x2F;</span><br><span class="line">    notify () &#123;</span><br><span class="line">        this.subs.forEach((sub) &#x3D;&gt; &#123;</span><br><span class="line">            sub.update();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>以上代码主要做两件事情：</p>
<ul>
<li>用 addSub 方法可以在目前的 <code>Dep</code> 对象中增加一个 <code>Watcher</code> 的订阅操作；</li>
<li>用 notify 方法通知目前 <code>Dep</code> 对象的 <code>subs</code> 中的所有 <code>Watcher</code> 对象触发更新操作。 所以当需要<code>依赖收集</code>的时候调用 addSub，当需要<code>派发更新</code>的时候调用 notify。</li>
</ul>
<p>调用也很简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let dp &#x3D; new Dep()</span><br><span class="line">dp.addSub(() &#x3D;&gt; &#123;&#x2F;&#x2F;依赖收集的时候</span><br><span class="line">    console.log(&#39;emit here&#39;)</span><br><span class="line">&#125;)</span><br><span class="line">dp.notify()&#x2F;&#x2F;派发更新的时候</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="5-观察者-Watcher"><a href="#5-观察者-Watcher" class="headerlink" title="5 观察者 Watcher"></a>5 观察者 Watcher</h2><h3 id="5-1-为什么引入Watcher"><a href="#5-1-为什么引入Watcher" class="headerlink" title="5.1 为什么引入Watcher"></a>5.1 为什么引入Watcher</h3><p>Vue 中定义一个 Watcher 类来表示<code>观察订阅依赖</code>。至于为啥引入Watcher，《深入浅出vue.js》给出了很好的解释:</p>
<p>当<code>属性</code>发生变化后，我们要通知<code>用到数据</code>的地方，而使用这个数据的地方有很多，而且类型还不一样，既有可能是模板，也有可能是用户写的一个watch,这时需要抽象出一个<code>能集中处理</code>这些情况的类。然后，我们在依赖收集阶段只收集这个封装好的类的实例进来，通知也只通知它一个，再由它负责通知其他地方。</p>
<p><strong>「依赖收集的目的是:」</strong> 将观察者 Watcher 对象存放到当前闭包中的订阅者 Dep 的 subs 中。形成如下所示的这样一个关系（图参考《剖析 Vue.js 内部运行机制》）。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/12/17343bec8082db69?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="5-2-Watcher的简单实现"><a href="#5-2-Watcher的简单实现" class="headerlink" title="5.2 Watcher的简单实现"></a>5.2 Watcher的简单实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Watcher &#123;</span><br><span class="line">  constructor(obj, key, cb) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将 Dep.target 指向自己</span><br><span class="line">    &#x2F;&#x2F; 然后触发属性的 getter 添加监听</span><br><span class="line">    &#x2F;&#x2F; 最后将 Dep.target 置空</span><br><span class="line">    Dep.target &#x3D; this</span><br><span class="line">    this.cb &#x3D; cb</span><br><span class="line">    this.obj &#x3D; obj</span><br><span class="line">    this.key &#x3D; key</span><br><span class="line">    this.value &#x3D; obj[key]</span><br><span class="line">    Dep.target &#x3D; null</span><br><span class="line">  &#125;</span><br><span class="line">  update() &#123;</span><br><span class="line">    &#x2F;&#x2F; 获得新值</span><br><span class="line">    this.value &#x3D; this.obj[this.key]</span><br><span class="line">   &#x2F;&#x2F; 我们定义一个 cb 函数，这个函数用来模拟视图更新，调用它即代表更新视图</span><br><span class="line">    this.cb(this.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>以上就是 Watcher 的简单实现，在执行构造函数的时候将 Dep.target 指向自身，从而使得收集到了对应的 Watcher，在派发更新的时候取出对应的 Watcher ,然后执行 update 函数。</p>
<p><strong>「依赖的本质：」</strong><br> 所谓的<code>依赖</code>，其实就是<code>Watcher</code>。<br> 至于如何收集依赖，总结起来就一句话:<br> 在<code>getter</code>中收集依赖，在<code>setter</code>中触发依赖。先收集依赖，即把用到该数据的地方<code>收集起来</code>，然后等<code>属性发生变化</code>时，把之前收集好的依赖<code>循环触发</code>一遍就行了。</p>
<p>具体来说，当外界通过Watcher<code>读取数据</code>时，便会触发<code>getter</code>从而将<code>Watcher添加到依赖中</code>，哪个Watcher触发了getter，就把哪个Watcher收集到Dep中。当数据发生变化时，会循环依赖列表，把所有的Watcher都通知一遍。</p>
<p>最后我们对 defineReactive 函数进行改造，在自定义函数中添加依赖收集和派发更新相关的代码,实现了一个简易的数据响应式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">function observe (obj) &#123;</span><br><span class="line">  &#x2F;&#x2F; 判断类型</span><br><span class="line">  if (!obj || typeof obj !&#x3D;&#x3D; &#39;object&#39;) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  Object.keys(obj).forEach(key &#x3D;&gt; &#123;</span><br><span class="line">    defineReactive(obj, key, obj[key])</span><br><span class="line">  &#125;)</span><br><span class="line">  function defineReactive (obj, key, value) &#123;</span><br><span class="line">    observe(value)  &#x2F;&#x2F; 递归子属性</span><br><span class="line">    let dp &#x3D; new Dep() &#x2F;&#x2F;新增</span><br><span class="line">    Object.defineProperty(obj, key, &#123;</span><br><span class="line">      enumerable: true, &#x2F;&#x2F;可枚举（可以遍历）</span><br><span class="line">      configurable: true, &#x2F;&#x2F;可配置（比如可以删除）</span><br><span class="line">      get: function reactiveGetter () &#123;</span><br><span class="line">        console.log(&#39;get&#39;, value) &#x2F;&#x2F; 监听</span><br><span class="line">     &#x2F;&#x2F; 将 Watcher 添加到订阅</span><br><span class="line">       if (Dep.target) &#123;</span><br><span class="line">         dp.addSub(Dep.target) &#x2F;&#x2F; 新增</span><br><span class="line">       &#125;</span><br><span class="line">        return value</span><br><span class="line">      &#125;,</span><br><span class="line">      set: function reactiveSetter (newVal) &#123;</span><br><span class="line">        observe(newVal) &#x2F;&#x2F;如果赋值是一个对象，也要递归子属性</span><br><span class="line">        if (newVal !&#x3D;&#x3D; value) &#123;</span><br><span class="line">          console.log(&#39;set&#39;, newVal) &#x2F;&#x2F; 监听</span><br><span class="line">          render()</span><br><span class="line">          value &#x3D; newVal</span><br><span class="line">     &#x2F;&#x2F; 执行 watcher 的 update 方法</span><br><span class="line">          dp.notify() &#x2F;&#x2F;新增</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Vue &#123;</span><br><span class="line">    constructor(options) &#123;</span><br><span class="line">        this._data &#x3D; options.data;</span><br><span class="line">        observer(this._data);</span><br><span class="line">        &#x2F;* 新建一个Watcher观察者对象，这时候Dep.target会指向这个Watcher对象 *&#x2F;</span><br><span class="line">        new Watcher();</span><br><span class="line">        console.log(&#39;模拟视图渲染&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>当 render function 被渲染的时候,<code>读取</code>所需对象的值，会触发 <code>reactiveGetter</code> 函数把当前的 Watcher 对象（存放在 Dep.target 中）收集到 Dep 类中去。之后如果<code>修改</code>对象的值，则会触发 <code>reactiveSetter</code> 方法，通知 Dep 类调用 <code>notify</code> 来触发所有 Watcher 对象的 <code>update</code> 方法更新对应视图。</p>
<p><strong>「完整流程图：」</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/12/17343bec82aa9093?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<ul>
<li>在 new Vue() 后， Vue 会调用_init 函数进行初始化，也就是init 过程，在 这个过程Data通过Observer转换成了getter/setter的形式，来对数据追踪变化，当被设置的对象被读取的时候会执行getter 函数，而在当被赋值的时候会执行 setter函数。</li>
<li>当外界通过Watcher读取数据时，会触发getter从而将Watcher添加到依赖中。</li>
<li>在修改对象的值的时候，会触发对应的setter， setter通知之前依赖收集得到的 Dep 中的每一个 Watcher，告诉它们自己的值改变了，需要重新渲染视图。这时候这些 Watcher就会开始调用 update 来更新视图。</li>
</ul>
<p><strong>「最后完整的响应式代码：」</strong></p>
<p>大概结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F;defineReactive是对Observer的抽离</span><br><span class="line">  const defineReactive &#x3D; function(obj, key) &#123;</span><br><span class="line">    &#x2F;&#x2F; 以下代码省略</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  const Vue &#x3D; function(options) &#123;</span><br><span class="line">    console.log(&quot;Vue&quot;,this)</span><br><span class="line">    &#x2F;&#x2F;打印1  Vue &#123;</span><br><span class="line">                  _data:&#123;</span><br><span class="line">                      text: &quot;123&quot;</span><br><span class="line">                      get text: ƒ get()</span><br><span class="line">                      set text: ƒ set(newVal)</span><br><span class="line">                    &#125;,</span><br><span class="line">                  mount: ƒ (),</span><br><span class="line">                  render: ƒ ()</span><br><span class="line">                &#125;</span><br><span class="line">    &#x2F;&#x2F; 以下代码省略</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  const Watcher &#x3D; function(vm, fn) &#123;</span><br><span class="line">    console.log(&quot;Watcher&quot;,this)</span><br><span class="line">    &#x2F;&#x2F;打印3 Watcher  this是下面的Dep中subs的对象</span><br><span class="line">    &#x2F;&#x2F; 以下代码省略</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  const Dep &#x3D; function() &#123;</span><br><span class="line">    console.log(&quot;Dep&quot;,this)</span><br><span class="line">    &#x2F;&#x2F;打印2  Dep   &#123; </span><br><span class="line">                    target: null,</span><br><span class="line">                    subs: [</span><br><span class="line">                      &#123;        &#x2F;&#x2F;是一个Watcher实例</span><br><span class="line">                        subs: Array(1)</span><br><span class="line">                        0: Watcher</span><br><span class="line">                        vm: &#123;    &#x2F;&#x2F;是一个Vue实例</span><br><span class="line">                            _data:&#123;</span><br><span class="line">                              text: &quot;123&quot;,&#x2F;&#x2F;该属性有了get和set方法</span><br><span class="line">                              get text: ƒ get(),</span><br><span class="line">                              set text: ƒ set(newVal)</span><br><span class="line">                            &#125;,</span><br><span class="line">                            mount: ƒ (),</span><br><span class="line">                            render: ƒ ()</span><br><span class="line">                          &#125;,</span><br><span class="line"></span><br><span class="line">                        addDep: ƒ (dep),</span><br><span class="line">                        update: ƒ (),</span><br><span class="line">                        value: undefined</span><br><span class="line">                      &#125;</span><br><span class="line">                    ],</span><br><span class="line">                    depend: ƒ (),</span><br><span class="line">                    addSub: ƒ (watcher),</span><br><span class="line">                    notify: ƒ ()</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 以下代码省略</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  const vue &#x3D; new Vue(&#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        text: &#39;hello world&#39;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  vue.mount(); </span><br><span class="line">  vue._data.text &#x3D; &#39;123&#39;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>详细代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">const Observer &#x3D; function(data) &#123;</span><br><span class="line">    console.log(1)   &#x2F;&#x2F;开始4 new Vue的时候就会执行</span><br><span class="line">  &#x2F;&#x2F; 循环修改为每个属性添加get set</span><br><span class="line">  for (let key in data) &#123;</span><br><span class="line">    defineReactive(data, key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const defineReactive &#x3D; function(obj, key) &#123;</span><br><span class="line">    console.log(2)    &#x2F;&#x2F;开始5 new Vue的时候就会执行</span><br><span class="line">  &#x2F;&#x2F; 局部变量dep，用于get set内部调用</span><br><span class="line">  const dep &#x3D; new Dep();</span><br><span class="line">  &#x2F;&#x2F; 获取当前值</span><br><span class="line">  let val &#x3D; obj[key];</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">      </span><br><span class="line">    &#x2F;&#x2F; 设置当前描述属性为可被循环</span><br><span class="line">    enumerable: true,</span><br><span class="line">    &#x2F;&#x2F; 设置当前描述属性可被修改</span><br><span class="line">    configurable: true,</span><br><span class="line">    get() &#123;</span><br><span class="line">        console.log(3)&#x2F;&#x2F;开始10  开始19</span><br><span class="line">      console.log(&#39;in get&#39;);</span><br><span class="line">      &#x2F;&#x2F; 调用依赖收集器中的addSub，用于收集当前属性与Watcher中的依赖关系</span><br><span class="line">      dep.depend();</span><br><span class="line">      return val;</span><br><span class="line">    &#125;,</span><br><span class="line">    set(newVal) &#123;</span><br><span class="line">        console.log(4)&#x2F;&#x2F;开始15</span><br><span class="line">      if (newVal &#x3D;&#x3D;&#x3D; val) &#123;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      val &#x3D; newVal;</span><br><span class="line">      &#x2F;&#x2F; 当值发生变更时，通知依赖收集器，更新每个需要更新的Watcher，</span><br><span class="line">      &#x2F;&#x2F; 这里每个需要更新通过什么断定？dep.subs</span><br><span class="line">      dep.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const observe &#x3D; function(data) &#123;</span><br><span class="line">    console.log(5)  &#x2F;&#x2F;开始3 new Vue的时候就会执行</span><br><span class="line">  return new Observer(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Vue &#x3D; function(options) &#123;</span><br><span class="line">    console.log(6)&#x2F;&#x2F;开始1 new Vue的时候就会执行</span><br><span class="line">  const self &#x3D; this;</span><br><span class="line">  &#x2F;&#x2F; 将data赋值给this._data，源码这部分用的Proxy所以我们用最简单的方式临时实现</span><br><span class="line">  if (options &amp;&amp; typeof options.data &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">    console.log(7)&#x2F;&#x2F;开始2   new Vue的时候就会执行</span><br><span class="line">    this._data &#x3D; options.data.apply(this);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 挂载函数</span><br><span class="line">  this.mount &#x3D; function() &#123;</span><br><span class="line">    console.log(8)  &#x2F;&#x2F;开始7  new Vue以后，执行vue.mount()</span><br><span class="line">    new Watcher(self, self.render);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 渲染函数</span><br><span class="line">  this.render &#x3D; function() &#123;</span><br><span class="line">    console.log(9) &#x2F;&#x2F;开始9 开始18  render函数执行后走到这里</span><br><span class="line">    with(self) &#123;</span><br><span class="line">      _data.text;  &#x2F;&#x2F;这里取data值的时候，就会走get方法</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 监听this._data</span><br><span class="line">  observe(this._data);  &#x2F;&#x2F;new Vue的时候就会执行,这里执行完，就表示new Vue的过程执行完了</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Watcher &#x3D; function(vm, fn) &#123;</span><br><span class="line">    console.log(10)  &#x2F;&#x2F;开始8  执行vue.mount()以后会走到这里</span><br><span class="line">  const self &#x3D; this;</span><br><span class="line">  this.vm &#x3D; vm;</span><br><span class="line">  &#x2F;&#x2F; 将当前Dep.target指向自己</span><br><span class="line">  Dep.target &#x3D; this;</span><br><span class="line">  &#x2F;&#x2F; 向Dep方法添加当前Wathcer</span><br><span class="line">  this.addDep &#x3D; function(dep) &#123;</span><br><span class="line">    console.log(11) &#x2F;&#x2F;开始13  </span><br><span class="line">    dep.addSub(self);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 更新方法，用于触发vm._render</span><br><span class="line">  this.update &#x3D; function() &#123;</span><br><span class="line">    console.log(12)&#x2F;&#x2F;开始17</span><br><span class="line">    console.log(&#39;in watcher update&#39;);</span><br><span class="line">    fn();</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 这里会首次调用vm._render，从而触发text的get</span><br><span class="line">  &#x2F;&#x2F; 从而将当前的Wathcer与Dep关联起来</span><br><span class="line">  this.value &#x3D; fn();   &#x2F;&#x2F;开始9  fn是render函数，这里fn()就会赋值的时候执行</span><br><span class="line">  &#x2F;&#x2F; 这里清空了Dep.target，为了防止notify触发时，不停的绑定Watcher与Dep，</span><br><span class="line">  &#x2F;&#x2F; 造成代码死循环</span><br><span class="line">  Dep.target &#x3D; null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Dep &#x3D; function() &#123;</span><br><span class="line">    console.log(13)  &#x2F;&#x2F;开始6  new Vue的时候就会执行到new Dep，然后执行到这里</span><br><span class="line">  const self &#x3D; this;</span><br><span class="line">  &#x2F;&#x2F; 收集目标</span><br><span class="line">  this.target &#x3D; null;</span><br><span class="line">  &#x2F;&#x2F; 存储收集器中需要通知的Watcher</span><br><span class="line">  this.subs &#x3D; [];</span><br><span class="line">  &#x2F;&#x2F; 当有目标时，绑定Dep与Wathcer的关系</span><br><span class="line"></span><br><span class="line">  this.depend &#x3D; function() &#123;</span><br><span class="line">    console.log(14)  &#x2F;&#x2F;开始11   开始20 走了get获取属性后，就要进行依赖收集 </span><br><span class="line">    if (Dep.target) &#123;</span><br><span class="line">        console.log(15)&#x2F;&#x2F;开始12  </span><br><span class="line">      &#x2F;&#x2F; 这里其实可以直接写self.addSub(Dep.target)，</span><br><span class="line">      &#x2F;&#x2F; 没有这么写因为想还原源码的过程。</span><br><span class="line">      Dep.target.addDep(self);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 为当前收集器添加Watcher</span><br><span class="line">  this.addSub &#x3D; function(watcher) &#123;</span><br><span class="line">    console.log(16)&#x2F;&#x2F;开始14</span><br><span class="line">    self.subs.push(watcher);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 通知收集器中所的所有Wathcer，调用其update方法</span><br><span class="line">  this.notify &#x3D; function() &#123;</span><br><span class="line">    console.log(17) &#x2F;&#x2F;开始16</span><br><span class="line">    for (let i &#x3D; 0; i &lt; self.subs.length; i +&#x3D; 1) &#123;</span><br><span class="line">      self.subs[i].update();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const vue &#x3D; new Vue(&#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      text: &#39;hello world&#39;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vue.mount(); &#x2F;&#x2F; in get</span><br><span class="line">vue._data.text &#x3D; &#39;123&#39;; &#x2F;&#x2F; in watcher update &#x2F;n in get</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong>「解析：」</strong></p>
<ul>
<li><ol>
<li>一开始new Vue ，会走到46行执行Vue构造函数，打印6</li>
</ol>
</li>
<li><ol>
<li>然后46行Vue的入参options实际上是127行的入参{data(){}}，是一个包含了data函数的对象，所以options.data是一个data函数，打印7。将vue中的data函数返回的数据赋值给_data。</li>
</ol>
</li>
<li><ol>
<li>然后走到67行的observe，会继续往上走到41行定义它的地方。</li>
</ol>
</li>
<li><ol>
<li>然后43行 new Observer 的时候会走到第一行<code>Observer(关键函数)</code>，打印1。我们发现Observer实际就是给data数据都添加<code>上get和set</code>方法，只不过不添加的方法defineReactive给抽离出去了。</li>
</ol>
</li>
<li><ol>
<li>然后走到第9行，执行defineReactive，打印2,然后15行给每个<code>属性</code>加上<code>get和set</code>方法。</li>
</ol>
</li>
<li><ol>
<li>然后走到12行，new Dep的时候，会走到95行执行Dep，打印13。Dep函数剩下的代码都只是定义函数，都不会执行，会跳出Dep函数。然后会到defineReactive函数第13行，defineReactive剩下的代码中的函数也不会执行，所以会回到Observer，再回到67行，即<code>new Vue的过程走完了</code>。</li>
</ol>
</li>
<li><ol>
<li>然后走到135行的vue.mount()，走到56行，打印8。</li>
</ol>
</li>
<li><ol>
<li>然后执行new Watcher走到70行，打印10，然后<strong>「Dep.target = this」</strong>，这一步将watch实例挂载到了Dep的target属性上，从而关联起来。</li>
</ol>
</li>
<li><ol>
<li>72行到88行只是定义，没有执行。89行this.value = fn()中：fn实际是传进来的<strong>「render」</strong>函数（看57行），然后后面又加了()就会立即执行。然后走到60行的render函数，打印9。<strong>「Watcher就执行完了」</strong>,然后，<strong>「关键的来了」</strong>：打印完9它会继续往下走，<strong>「读取_data.text」</strong>。那么，这一步就会触发get方法（这一步的目的就只是为了触发get，所以获取值就行了，并不需要做其他操作）。</li>
</ol>
</li>
<li><ol>
<li>然后走到21行的get，打印3。</li>
</ol>
</li>
<li><ol>
<li>然后走到25行，执行dep.depend()，再走到104行，打印14。</li>
</ol>
</li>
<li><ol>
<li>这时候判断Dep.target，由于第8步将watch挂载到了Dep.target，这时候为true，所以打印15。</li>
</ol>
</li>
<li><ol>
<li>然后走到110行，再跳到77行，打印11。</li>
</ol>
</li>
<li><ol>
<li>79行执行后会跳到114行，打印16，完成了依赖收集，然后会回到Watch，执行最后一行，Dep.target = null，避免陷入死循环，然后Watch执行完了，<strong>「vue.mount()也执行完了」</strong>。。</li>
</ol>
</li>
<li><ol>
<li>然后就是136行赋值操作了，这时候会走到28行的set，打印4。</li>
</ol>
</li>
<li><ol>
<li>继续向下走，到36行，dep.notify()，然后走到119行，打印17。</li>
</ol>
</li>
<li><ol>
<li>然后会走到122行，触发update，走到82行，打印12。</li>
</ol>
</li>
<li><ol>
<li>然后执行fn()，即render函数，走到60行，打印9。</li>
</ol>
</li>
<li><ol>
<li>然后走到63行，取data值，会走get，走到21，打印3。</li>
</ol>
</li>
<li><ol>
<li>然后25行，会跳到104行，打印14。Dep.target为null，15不会打印</li>
</ol>
</li>
</ul>
<p>  链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6850418111985352711">https://juejin.cn/post/6850418111985352711</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2020/12/08/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/">http://example.com/2020/12/08/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Hexo</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="http://www.obzhi.com/wp-content/uploads/2021/01/mojie2-1024x470.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/03/09/%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE/"><img class="prev-cover" src="http://www.obzhi.com/wp-content/uploads/2021/01/mojie2-1024x470.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">获取当前地理位置</div></div></a></div><div class="next-post pull-right"><a href="/2020/11/20/vue-js-%E4%BA%8C%E7%BA%A7%E8%B7%AF%E7%94%B1-%E4%B8%89%E7%BA%A7%E8%B7%AF%E7%94%B1/"><img class="next-cover" src="http://121.40.114.220/wp-content/uploads/2016/11/loner.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">vue.js 二级路由/三级路由</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/null" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xxxxx" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFVue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%91%A2"><span class="toc-number">1.</span> <span class="toc-text">1 什么是Vue响应式呢</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%83%B3%E5%AE%8C%E6%88%90%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%EF%BC%8C%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E5%81%9A%E4%BA%9B%E4%BB%80%E4%B9%88"><span class="toc-number">2.</span> <span class="toc-text">2 想完成这个过程，我们需要做些什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E4%BE%A6%E6%B5%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">3.</span> <span class="toc-text">3 如何侦测数据的变化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Object-defineProperty%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.1.</span> <span class="toc-text">3.1  Object.defineProperty实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">3.1.1.</span> <span class="toc-text">代码如下：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Proxy%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.</span> <span class="toc-text">3.2  Proxy实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%94%B6%E9%9B%86%E4%BE%9D%E8%B5%96"><span class="toc-number">4.</span> <span class="toc-text">4. 收集依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%94%B6%E9%9B%86%E4%BE%9D%E8%B5%96"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 为什么要收集依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E8%AE%A2%E9%98%85%E8%80%85-Dep"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 订阅者 Dep</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%A7%82%E5%AF%9F%E8%80%85-Watcher"><span class="toc-number">5.</span> <span class="toc-text">5 观察者 Watcher</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5Watcher"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 为什么引入Watcher</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Watcher%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 Watcher的简单实现</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/07/19/%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%88%87%E6%8D%A2/" title="登录注册页面的切换"><img src="http://www.obzhi.com/wp-content/uploads/2020/11/%E9%BB%91%E7%8C%AB.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="登录注册页面的切换"/></a><div class="content"><a class="title" href="/2021/07/19/%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%88%87%E6%8D%A2/" title="登录注册页面的切换">登录注册页面的切换</a><time datetime="2021-07-19T06:54:30.000Z" title="发表于 2021-07-19 14:54:30">2021-07-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/16/%E5%A6%82%E4%BD%95%E5%BC%95%E7%94%A8element-UI%E7%BB%84%E4%BB%B6/" title="如何引用element-UI组件"><img src="http://www.obzhi.com/wp-content/uploads/2020/08/C3F0A095-EFA7-41F5-9162-CDE3FD83D6E1.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何引用element-UI组件"/></a><div class="content"><a class="title" href="/2021/03/16/%E5%A6%82%E4%BD%95%E5%BC%95%E7%94%A8element-UI%E7%BB%84%E4%BB%B6/" title="如何引用element-UI组件">如何引用element-UI组件</a><time datetime="2021-03-16T07:11:57.000Z" title="发表于 2021-03-16 15:11:57">2021-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/09/%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE/" title="获取当前地理位置"><img src="http://www.obzhi.com/wp-content/uploads/2021/01/mojie2-1024x470.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="获取当前地理位置"/></a><div class="content"><a class="title" href="/2021/03/09/%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE/" title="获取当前地理位置">获取当前地理位置</a><time datetime="2021-03-09T06:31:58.000Z" title="发表于 2021-03-09 14:31:58">2021-03-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/08/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/" title="Vue响应式原理"><img src="http://www.obzhi.com/wp-content/uploads/2021/01/mojie2-1024x470.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vue响应式原理"/></a><div class="content"><a class="title" href="/2020/12/08/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/" title="Vue响应式原理">Vue响应式原理</a><time datetime="2020-12-08T07:45:47.000Z" title="发表于 2020-12-08 15:45:47">2020-12-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/20/vue-js-%E4%BA%8C%E7%BA%A7%E8%B7%AF%E7%94%B1-%E4%B8%89%E7%BA%A7%E8%B7%AF%E7%94%B1/" title="vue.js 二级路由/三级路由"><img src="http://121.40.114.220/wp-content/uploads/2016/11/loner.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vue.js 二级路由/三级路由"/></a><div class="content"><a class="title" href="/2020/11/20/vue-js-%E4%BA%8C%E7%BA%A7%E8%B7%AF%E7%94%B1-%E4%B8%89%E7%BA%A7%E8%B7%AF%E7%94%B1/" title="vue.js 二级路由/三级路由">vue.js 二级路由/三级路由</a><time datetime="2020-11-20T07:50:47.000Z" title="发表于 2020-11-20 15:50:47">2020-11-20</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By John Doe</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>